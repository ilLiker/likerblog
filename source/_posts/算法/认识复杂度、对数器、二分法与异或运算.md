---
Title: 认识复杂度、对数器、二分法与异或运算

---

```
评估算法优劣的核心指标
	时间复杂度（流程决定）
	额外空间复杂度（流程决定）
	常数项时间（实现细节决定）
```

#### 常数时间的操作：

```

		如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定的，称这样的操作为常数时间的操作。
常见的常数时间的操作
	常见的算术运算（+、-、*、/、%等）
	常见的位运算（>>、>>>、<<、｜、&、^）
	赋值、比较、自增、自减操作等
	数组寻址操作
	
	总之，执行时间固定的操作都是常数时间的操作。
	反之，执行时间不固定的操作，都不是常数时间的操作。
	例如ArrayList的get(i)就是常数时间操作。
		 LinkedList的get(i)就不是常数时间操作。因为不是算的偏移量寻址，而是便利寻址；
	>> >>> 的区别 
		>> 	带符号位移
		>>> 不带符号位移
	
```

## 时间复杂度

```
如何确定算法流程的总操作数量与样本数量之间的表达式关系？
	1，想象该算法流程所处理的数据状况，按照最差的情况。
	2，把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。
	3，如果数据量为N，看看基本动作的数量和N是什么关系。
如何确定算法流程的时间复杂度？
	当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。
	记为：O(忽略掉系数的高阶项)
	
举例：
	选择排序：
		过程：
			arr[0~N-1]范围上，找到最小值所在的位置，然后把最小值与0位置的数交换；
			arr[1~N-1]范围上，找到最小值所在的位置，然后把最小值与1位置的数交换；
			arr[2~N-1]范围上，找到最小值所在的位置，然后把最小值与1位置的数交换；
			...
      arr[N-1~N-1]范围上，找到最小值所在的位置，然后把最小值与1位置的数交换；
    估算：
    	很明显，如果arr长度为N，每一步常数操作的数量，就是一个等差数列。所以常数操作的数量为 a*(N^2) + b*N + c
    所以选择排序的时间复杂度为O(N^2)
    
 注意：
 		1）算法的过程，和具体的语言是无关的。
 		2）想分析一个算法流程的时间复杂度的前提，是对该流程非常熟悉
 		3）一定要拆分算法流程时，拆分出来的所有行为都是常数时间的操作。这意味着你写算法时，对自己用过的每一个api系统，都非常熟悉。否则会影响你对时间复杂的估算。
```

## 额外空间复杂度

```
你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。
作为输入参数的空间，不算额外空间。
作为输出结果的空间，也不算额外空间。

因为这些都是必要的、和实现目标有关。所以都不算。
但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。
如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)
```

## 算法流程的常数项

```
时间复杂度这个指标，是忽略低阶项和所有常数系数的。
时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，就还要在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。
```



```
面试、比赛、刷题中，一个问题的最优解是什么意思？
	一般情况下，认为解决一个问题的算法流程，在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低这个指标后，使用最少的空间的算法流程，叫这个问题的最优解。
	一般说起最优解都是忽略掉常数项这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。
```

## 认识对数器

```
1,你想要测的方法a
2,实现复杂度不要但是容易实现的方法b
3,实现一个随机样本产生器
4,把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。
5,如果一个随机样本使得对比结果不一致，打印样本进行人工干预，改对方法a和方法b
6,当样本数量很多时对比测试依然正确，可以确定方法a已经正确。
```

## 认识二分法

```
经常见到的类型是在一个有序数组上，开展二分搜索
但有序真的是所有问题求解时使用二分的必要条件么？
只要能正确构建左右两侧淘汰逻辑，就可以二分；
1）在一个有序数组中，找某个数是否存在
2）在一个有序数组中，找>=某个数最左侧的位置
3）在一个有序数组中，找<=某个数最右侧的位置
4）局部最小值问题
```

#### 异或运算

```
异或运算：相同为0，不同为1
同或运算：相同以1，不同为0

异或运算就记为无进位相加

1）0^N == N N^N == 0
2）异或运算满足交换律和结合率
```

## 例题：

### 如何不用额外变量交换两个数

```
public static void main(String[] args) {
        int a = 5;
        int b = 7;
        a = a ^ b;  // a = a ^ b
        b = a ^ b;  // b = (a ^ b) ^ b = a ^ b ^ b = a
        a = a ^ b;  // a = (a ^ b(7)) ^ b(5) = 5 ^ 7 ^ 5 = b = 7
        System.out.println(a + "\t" + b);
    }
```

### 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种树

```
  public static void findOnlyOneOddNumber(int[] arr){
        int cou = 0;
        for (int i : arr) {
            cou ^= i;
        }
        System.out.println(cou);
    }
```

### 怎么把一个int类型的数，提取出最右侧的1来

```
假如有一个数 01010100
先取反再加1得。   10101011  + 1 =  10101100
在与原来的数&运算 								 01010100 = 00000100
System.out.println(i & (~i + 1));
```

#### 一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

```
有两种数出现奇数次，假设为a,b 那么对所有数进行^运算得出的结果为a ^ b。
另cou = a ^ b，且a ^ b 不等于0那么在cou中为1的地方肯定是a,b两个数中只有一个数在这个位置上是1。
那么对cou: cou & (~cou + 1) 取出最右边的1 
另 cou2 = cou & (~cou + 1)
那么对所有数在进行循环做^操作，但是只对与 cou2 与运算为0时的数字。
这是就会a/b其中的一个。在对取出的数与cou^即可得出另外一个的结果。
public static void findOnlyTwoOddNumber(int[] arr){
        int cou = 0;
        for (int i : arr) {
            cou ^= i;
        }
        int j = cou & (~cou + 1);
        int end = 0;
        for (int i : arr) {
            if((i & j) != 0){
                end ^= i;
            }
        }
        System.out.println(end + "\t" + (end ^ cou));
    }
```

