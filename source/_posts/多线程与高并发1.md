---
title: 多线程与高并发01
tags: 线程的概念，启动方式，常用方法
renderNumberedHeading: true
grammar_cjkRuby: true
---

### synchronized(Object)
	object不能用String常量，Integer，Long。因为他们在常量池中，线程之间会共享。加锁可能会加到意料之外的代码中。
	
### 线程同步
	-synchronized
		·锁的是对象，不是代码。
		·synchronized == synchronized(XX.class) , 即锁的是当前类的类对象
		·锁定方法，非锁定方法 同时执行会造成脏读
		·锁升级
			- 偏向锁 -> 自旋锁 -> 重量级锁
			- 自旋锁切换到重量级锁的时候需要从用户态切换到内核态

### 锁升级过程


```
  	无锁 --> 偏向锁 --> 自旋锁 --> 重量级锁
	
```
```
	无锁：未加锁态
```
```
	偏向锁(轻量级锁)：加锁的时候加上一个标记，当线程重新去执行时，判断这个标记是否是自己的标记，如果是，直接执行；效率高；
		1.默认情况 偏向锁有个时延，默认是4秒
		2.why? ...
		
		3.上偏向锁，指的就是，把markword的线程ID改为自己的线程ID的过程；
```
```
	自旋锁：指的是阻塞态的线程通过自旋的方式去获取锁(while(true))，这种方式的好处是，只需要在用户态即可完成，无需切换到内核态。在线程运行时间短，争用的线程少的情况下效率比较高；
```

```
	重量级锁：等待线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间
		优点：不占用cpu；
		缺点：需要从用户态切换到内核态；
```

```
	升级过程：
		1. Object o = new Object()
		2. 默认synchronized(o)
			1. 00->轻量级锁
			2. 默认情况 偏向锁有个时延，默认是4秒 
			3. why? 因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。
		3. 如果有线程上锁
			1. 上偏向锁，就是把markword的线程ID改为自己的线程ID的过程
		4. 如果有线程竞争
			1. 撤销偏向锁，升级轻量级锁
			2. 线程在自己的线程栈生成LockRecord，用CAS操作将markword设置为指向自己这个线程的LR指针，设置成功者的到锁
			3.  
		5. 如果竞争加剧
			1. 有线程超过10次自旋，-XX:PreBlockSpin可以设置，或者自选线程数超过CPU核数的一半，在jdk1.6之后，加入自适应自旋 Adapative Self Spinning，JVM自己控制 
			2. CPU从3级-0级系统调用，线程挂起，进入等待队列，等待操作系统的调度，然后在映射回用户空间；
		6. 
			 
```
	

